@startuml thread_pool

class ThreadPool {
    - vector<jthread> m_pool
    - WQueue<ITask, WPQueue<ITask>> m_pq
    - bool m_stat
    
    + void Add(shared_ptr<ITask>, Priority)
    + void Resume()
    + void Pause() 
    + void Stop()
    + void SetNumThread(size_t num_of_threads)
}

enum ThreadPool::Priority {
    LOW
    MID
    HIGH
}

abstract ThreadPool::ITask {
    + virtual void operator()() = 0
}

class ThreadPool::PriorityTask {
    - std::shared_ptr<ITask> m_task
    - SuperPriority m_superPrior

    + SuperPriority GetPriority() const
    + bool operator<(const PriorityTask&) const
    + void operator()()
}

enum PriorityTask::SuperPriority {
    LOW
    MID
    HIGH
    SUPER
    ULTRA
}

class WQueue<ThreadPool::PriorityTask, WPQueue> {
    - Container m_container
    - timed_mutex m_mutex
    - condition_variable_any m_condition
    
    + void Pop(PriorityTask*)
    + wqueue_status Pop(PriorityTask*, const milliseconds)
    + void Push(const PriorityTask&)
    + bool IsEmpty() const
}

enum wqueue_status {
    SUCCESS
    TIME_OUT_EMPTY
    TIME_OUT_LOCK
}


class WPQueue <std::priority_queue> {
    - std::priority_queue<PriorityTask> m_pq
    
    + void empty() const
    + PriorityTask& front() const
    + void push_back(const PriorityTask&)
    + void pop_front()
}

class std::priority_queue  <vector<ThreadPool::PriorityTask>>
class std::timed_mutex
class std::contition_variable_any


ThreadPool *-down- WQueue
ThreadPool - ThreadPool::Priority

WQueue::wqueue_status <-left- wqueue_status : return val
WQueue *-- WPQueue
WQueue *-- std::timed_mutex
WQueue *-- std::contition_variable_any

WPQueue *-- std::priority_queue
std::priority_queue *-- ThreadPool::PriorityTask

ThreadPool::PriorityTask *-- ThreadPool::ITask
ThreadPool::PriorityTask::GetPriority <-right- PriorityTask::SuperPriority




@enduml
